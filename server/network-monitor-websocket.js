/**
 * Network Monitor WebSocket Server
 * WebSocket —Å–µ—Ä–≤–µ—Ä –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–µ—Ç–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
 */

const WebSocket = require('ws');
const { EventEmitter } = require('events');

class NetworkMonitorWebSocket extends EventEmitter {
  constructor(port = 13084) {
    super();
    this.port = port;
    this.wss = null;
    this.clients = new Set();
    this.isRunning = false;
    
    // –°–∏–º—É–ª—è—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö (–≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –±—É–¥–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å TypeScript –º–æ–¥—É–ª—è–º–∏)
    this.mockData = {
      connections: new Map(),
      routes: new Map(),
      events: [],
      alerts: { performance: [], security: [] }
    };
    
    this.initializeMockData();
  }
  
  /**
   * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
   */
  initializeMockData() {
    // –°–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–µ—Å—Ç–æ–≤—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
    this.mockData.connections.set('conn_1', {
      id: 'conn_1',
      destination: 'api.openai.com',
      port: 443,
      protocol: 'https',
      type: 'proxy',
      status: 'connected',
      startTime: Date.now() - 30000,
      lastActivity: Date.now(),
      bytesIn: 1024 * 50,
      bytesOut: 1024 * 20,
      latency: 250
    });
    
    this.mockData.connections.set('conn_2', {
      id: 'conn_2',
      destination: 'yandex.ru',
      port: 443,
      protocol: 'https',
      type: 'direct',
      status: 'connected',
      startTime: Date.now() - 15000,
      lastActivity: Date.now() - 1000,
      bytesIn: 1024 * 30,
      bytesOut: 1024 * 10,
      latency: 45
    });
    
    // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã
    this.mockData.routes.set('direct', {
      id: 'direct',
      name: 'Direct Connection',
      type: 'direct',
      healthy: true,
      weight: 100,
      metrics: {
        requests: 150,
        errors: 2,
        avgLatency: 45,
        throughput: 1024 * 1024 * 2
      }
    });
    
    this.mockData.routes.set('ai_proxy', {
      id: 'ai_proxy',
      name: 'AI Proxy Server',
      type: 'proxy',
      healthy: true,
      weight: 90,
      metrics: {
        requests: 89,
        errors: 1,
        avgLatency: 250,
        throughput: 1024 * 1024 * 1.5
      }
    });
  }
  
  /**
   * –ó–∞–ø—É—Å–∫ WebSocket —Å–µ—Ä–≤–µ—Ä–∞
   */
  start() {
    if (this.isRunning) {
      console.log('üîÑ Network Monitor WebSocket server is already running');
      return;
    }
    
    try {
      this.wss = new WebSocket.Server({ 
        port: this.port,
        perMessageDeflate: false
      });
      
      this.wss.on('connection', (ws, request) => {
        this.handleConnection(ws, request);
      });
      
      this.wss.on('error', (error) => {
        console.error('‚ùå WebSocket server error:', error);
        this.emit('error', error);
      });
      
      this.isRunning = true;
      
      // –ó–∞–ø—É—Å–∫–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
      this.startDataGeneration();
      
      console.log(`üöÄ Network Monitor WebSocket server started on port ${this.port}`);
      console.log(`üìä Real-time network monitoring available at ws://localhost:${this.port}`);
      
      this.emit('started');
      
    } catch (error) {
      console.error('‚ùå Failed to start Network Monitor WebSocket server:', error);
      this.emit('error', error);
    }
  }
  
  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
   */
  handleConnection(ws, request) {
    const clientId = this.generateClientId();
    const clientInfo = {
      id: clientId,
      ws: ws,
      ip: request.socket.remoteAddress,
      userAgent: request.headers['user-agent'],
      connectedAt: new Date(),
      subscriptions: new Set(['all']) // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –≤—Å–µ —Å–æ–±—ã—Ç–∏—è
    };
    
    this.clients.add(clientInfo);
    
    console.log(`üì± New client connected: ${clientId} from ${clientInfo.ip}`);
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    this.sendToClient(clientInfo, {
      type: 'welcome',
      data: {
        clientId: clientId,
        serverTime: Date.now(),
        availableSubscriptions: ['all', 'connections', 'routes', 'events', 'alerts']
      }
    });
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    this.sendCurrentState(clientInfo);
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞
    ws.on('message', (message) => {
      this.handleClientMessage(clientInfo, message);
    });
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    ws.on('close', (code, reason) => {
      console.log(`üì± Client disconnected: ${clientId} (${code}: ${reason})`);
      this.clients.delete(clientInfo);
    });
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
    ws.on('error', (error) => {
      console.error(`‚ùå Client error ${clientId}:`, error);
      this.clients.delete(clientInfo);
    });
  }
  
  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞
   */
  handleClientMessage(clientInfo, message) {
    try {
      const data = JSON.parse(message.toString());
      
      switch (data.type) {
        case 'subscribe':
          this.handleSubscription(clientInfo, data.subscriptions);
          break;
          
        case 'unsubscribe':
          this.handleUnsubscription(clientInfo, data.subscriptions);
          break;
          
        case 'get_snapshot':
          this.sendNetworkSnapshot(clientInfo);
          break;
          
        case 'get_connections':
          this.sendConnectionsData(clientInfo);
          break;
          
        case 'get_routes':
          this.sendRoutesData(clientInfo);
          break;
          
        case 'ping':
          this.sendToClient(clientInfo, { type: 'pong', timestamp: Date.now() });
          break;
          
        default:
          this.sendToClient(clientInfo, {
            type: 'error',
            message: `Unknown message type: ${data.type}`
          });
      }
    } catch (error) {
      console.error('Error handling client message:', error);
      this.sendToClient(clientInfo, {
        type: 'error',
        message: 'Invalid message format'
      });
    }
  }
  
  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏
   */
  handleSubscription(clientInfo, subscriptions) {
    if (Array.isArray(subscriptions)) {
      subscriptions.forEach(sub => clientInfo.subscriptions.add(sub));
    }
    
    this.sendToClient(clientInfo, {
      type: 'subscription_updated',
      data: {
        subscriptions: Array.from(clientInfo.subscriptions)
      }
    });
  }
  
  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø–∏—Å–∫–∏
   */
  handleUnsubscription(clientInfo, subscriptions) {
    if (Array.isArray(subscriptions)) {
      subscriptions.forEach(sub => clientInfo.subscriptions.delete(sub));
    }
    
    this.sendToClient(clientInfo, {
      type: 'subscription_updated',
      data: {
        subscriptions: Array.from(clientInfo.subscriptions)
      }
    });
  }
  
  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
   */
  sendCurrentState(clientInfo) {
    this.sendNetworkSnapshot(clientInfo);
    this.sendConnectionsData(clientInfo);
    this.sendRoutesData(clientInfo);
  }
  
  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–Ω–∏–º–∫–∞ —Å–µ—Ç–∏
   */
  sendNetworkSnapshot(clientInfo) {
    const snapshot = {
      timestamp: Date.now(),
      connections: {
        total: this.mockData.connections.size,
        active: Array.from(this.mockData.connections.values()).filter(c => c.status === 'connected').length,
        byType: this.groupConnectionsByType(),
        byStatus: this.groupConnectionsByStatus()
      },
      routes: {
        total: this.mockData.routes.size,
        healthy: Array.from(this.mockData.routes.values()).filter(r => r.healthy).length,
        byType: this.groupRoutesByType()
      },
      performance: this.calculatePerformanceMetrics(),
      alerts: this.mockData.alerts
    };
    
    this.sendToClient(clientInfo, {
      type: 'network_snapshot',
      data: snapshot
    });
  }
  
  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è—Ö
   */
  sendConnectionsData(clientInfo) {
    const connections = Array.from(this.mockData.connections.values());
    
    this.sendToClient(clientInfo, {
      type: 'connections_data',
      data: {
        connections,
        stats: {
          total: connections.length,
          active: connections.filter(c => c.status === 'connected').length,
          byType: this.groupConnectionsByType(),
          byStatus: this.groupConnectionsByStatus()
        }
      }
    });
  }
  
  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –æ –º–∞—Ä—à—Ä—É—Ç–∞—Ö
   */
  sendRoutesData(clientInfo) {
    const routes = Array.from(this.mockData.routes.values());
    
    this.sendToClient(clientInfo, {
      type: 'routes_data',
      data: {
        routes,
        stats: {
          total: routes.length,
          healthy: routes.filter(r => r.healthy).length,
          byType: this.groupRoutesByType()
        }
      }
    });
  }
  
  /**
   * –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –ø–æ —Ç–∏–ø—É
   */
  groupConnectionsByType() {
    const groups = {};
    for (const conn of this.mockData.connections.values()) {
      groups[conn.type] = (groups[conn.type] || 0) + 1;
    }
    return groups;
  }
  
  /**
   * –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –ø–æ —Å—Ç–∞—Ç—É—Å—É
   */
  groupConnectionsByStatus() {
    const groups = {};
    for (const conn of this.mockData.connections.values()) {
      groups[conn.status] = (groups[conn.status] || 0) + 1;
    }
    return groups;
  }
  
  /**
   * –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –º–∞—Ä—à—Ä—É—Ç–æ–≤ –ø–æ —Ç–∏–ø—É
   */
  groupRoutesByType() {
    const groups = {};
    for (const route of this.mockData.routes.values()) {
      groups[route.type] = (groups[route.type] || 0) + 1;
    }
    return groups;
  }
  
  /**
   * –†–∞—Å—á–µ—Ç –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
   */
  calculatePerformanceMetrics() {
    const connections = Array.from(this.mockData.connections.values());
    const routes = Array.from(this.mockData.routes.values());
    
    const totalLatency = connections.reduce((sum, conn) => sum + conn.latency, 0);
    const avgLatency = connections.length > 0 ? totalLatency / connections.length : 0;
    
    const totalRequests = routes.reduce((sum, route) => sum + route.metrics.requests, 0);
    const totalErrors = routes.reduce((sum, route) => sum + route.metrics.errors, 0);
    const errorRate = totalRequests > 0 ? (totalErrors / totalRequests) * 100 : 0;
    
    const totalThroughput = routes.reduce((sum, route) => sum + route.metrics.throughput, 0);
    
    return {
      averageLatency: Math.round(avgLatency),
      totalThroughput: Math.round(totalThroughput),
      errorRate: Math.round(errorRate * 100) / 100,
      successRate: Math.round((100 - errorRate) * 100) / 100
    };
  }
  
  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç—É
   */
  sendToClient(clientInfo, message) {
    if (clientInfo.ws.readyState === WebSocket.OPEN) {
      try {
        clientInfo.ws.send(JSON.stringify(message));
      } catch (error) {
        console.error(`Error sending message to client ${clientInfo.id}:`, error);
      }
    }
  }
  
  /**
   * –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤—Å–µ–º –∫–ª–∏–µ–Ω—Ç–∞–º
   */
  broadcast(message, subscription = 'all') {
    for (const clientInfo of this.clients) {
      if (clientInfo.subscriptions.has(subscription) || clientInfo.subscriptions.has('all')) {
        this.sendToClient(clientInfo, message);
      }
    }
  }
  
  /**
   * –ó–∞–ø—É—Å–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
   */
  startDataGeneration() {
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
    setInterval(() => {
      this.updateMockData();
      this.broadcastUpdates();
    }, 5000);
    
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏–π –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã
    setInterval(() => {
      this.generateMockEvent();
    }, 2000);
    
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
    setInterval(() => {
      this.generateMockAlert();
    }, 30000);
  }
  
  /**
   * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
   */
  updateMockData() {
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
    for (const conn of this.mockData.connections.values()) {
      conn.lastActivity = Date.now();
      conn.bytesIn += Math.floor(Math.random() * 1024 * 10);
      conn.bytesOut += Math.floor(Math.random() * 1024 * 5);
      conn.latency = Math.max(10, conn.latency + (Math.random() - 0.5) * 50);
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏ –º–∞—Ä—à—Ä—É—Ç–æ–≤
    for (const route of this.mockData.routes.values()) {
      route.metrics.requests += Math.floor(Math.random() * 5);
      route.metrics.errors += Math.random() > 0.9 ? 1 : 0;
      route.metrics.avgLatency = Math.max(10, route.metrics.avgLatency + (Math.random() - 0.5) * 20);
      route.metrics.throughput = Math.max(0, route.metrics.throughput + (Math.random() - 0.5) * 1024 * 100);
    }
  }
  
  /**
   * –†–∞—Å—Å—ã–ª–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
   */
  broadcastUpdates() {
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Å–Ω–∏–º–æ–∫ —Å–µ—Ç–∏
    const snapshot = {
      timestamp: Date.now(),
      connections: {
        total: this.mockData.connections.size,
        active: Array.from(this.mockData.connections.values()).filter(c => c.status === 'connected').length,
        byType: this.groupConnectionsByType(),
        byStatus: this.groupConnectionsByStatus()
      },
      routes: {
        total: this.mockData.routes.size,
        healthy: Array.from(this.mockData.routes.values()).filter(r => r.healthy).length,
        byType: this.groupRoutesByType()
      },
      performance: this.calculatePerformanceMetrics(),
      alerts: this.mockData.alerts
    };
    
    this.broadcast({
      type: 'network_snapshot',
      data: snapshot
    });
  }
  
  /**
   * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å–æ–±—ã—Ç–∏—è
   */
  generateMockEvent() {
    const eventTypes = ['connection_created', 'connection_closed', 'route_changed', 'performance_alert'];
    const severities = ['info', 'warning', 'error'];
    
    const event = {
      type: eventTypes[Math.floor(Math.random() * eventTypes.length)],
      timestamp: Date.now(),
      severity: severities[Math.floor(Math.random() * severities.length)],
      data: {
        message: `Mock event generated at ${new Date().toISOString()}`,
        details: `Random event for testing purposes`
      }
    };
    
    this.mockData.events.push(event);
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–±—ã—Ç–∏–π
    if (this.mockData.events.length > 100) {
      this.mockData.events.shift();
    }
    
    this.broadcast({
      type: 'network_event',
      data: event
    }, 'events');
  }
  
  /**
   * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
   */
  generateMockAlert() {
    if (Math.random() > 0.7) { // 30% –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å
      const alertTypes = ['high_latency', 'connection_timeout', 'route_failure'];
      const alertType = alertTypes[Math.floor(Math.random() * alertTypes.length)];
      
      const alert = {
        type: alertType,
        threshold: 1000,
        currentValue: 1500,
        affectedConnections: ['conn_1'],
        suggestedAction: 'Consider switching to a different route',
        timestamp: Date.now()
      };
      
      this.mockData.alerts.performance.push(alert);
      
      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π
      if (this.mockData.alerts.performance.length > 10) {
        this.mockData.alerts.performance.shift();
      }
      
      this.broadcast({
        type: 'performance_alert',
        data: alert
      }, 'alerts');
    }
  }
  
  /**
   * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è ID –∫–ª–∏–µ–Ω—Ç–∞
   */
  generateClientId() {
    return `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞
   */
  getStats() {
    return {
      isRunning: this.isRunning,
      port: this.port,
      connectedClients: this.clients.size,
      mockDataStats: {
        connections: this.mockData.connections.size,
        routes: this.mockData.routes.size,
        events: this.mockData.events.length,
        performanceAlerts: this.mockData.alerts.performance.length,
        securityAlerts: this.mockData.alerts.security.length
      }
    };
  }
  
  /**
   * –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞
   */
  stop() {
    if (!this.isRunning) {
      console.log('‚ö†Ô∏è Network Monitor WebSocket server is not running');
      return;
    }
    
    try {
      // –ó–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
      for (const clientInfo of this.clients) {
        clientInfo.ws.close(1000, 'Server shutting down');
      }
      
      // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–µ—Ä–≤–µ—Ä
      this.wss.close(() => {
        console.log('üõë Network Monitor WebSocket server stopped');
        this.emit('stopped');
      });
      
      this.isRunning = false;
      this.clients.clear();
      
    } catch (error) {
      console.error('‚ùå Error stopping Network Monitor WebSocket server:', error);
      this.emit('error', error);
    }
  }
}

// –°–æ–∑–¥–∞–µ–º –∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä
const networkMonitorWS = new NetworkMonitorWebSocket();

// –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –µ—Å–ª–∏ —Ñ–∞–π–ª –∑–∞–ø—É—â–µ–Ω –Ω–∞–ø—Ä—è–º—É—é
if (require.main === module) {
  networkMonitorWS.start();
  
  // Graceful shutdown
  process.on('SIGINT', () => {
    console.log('\\nüõë Received SIGINT, shutting down gracefully...');
    networkMonitorWS.stop();
    process.exit(0);
  });
  
  process.on('SIGTERM', () => {
    console.log('\\nüõë Received SIGTERM, shutting down gracefully...');
    networkMonitorWS.stop();
    process.exit(0);
  });
}

module.exports = networkMonitorWS;